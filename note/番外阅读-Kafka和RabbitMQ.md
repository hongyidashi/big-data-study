# 番外阅读-Kafka和RabbitMQ
1. [异步消息模式](#异步消息模式)
2. [RabbitMQ](#RabbitMQ)
3. [Kafka](#Kafka)


## <span id="异步消息模式">异步消息模式</span>
异步消息可以作为解耦消息的生产和处理的一种解决方案。提到消息系统，我们通常会想到两种主要的消息模式——消息队列和发布/订阅模式。

**消息队列**  
多个生产者可以向同一个消息队列发送消息；但是，一个消息在被一个消息者处理的时候，这个消息在队列上会被锁住或者被移除并且其他消费者无法处理该消息。
也就是说**一个具体的消息只能由一个消费者消费**。

![消息队列]()

如果消费者处理一个消息失败了，消息系统一般会把这个消息放回队列，这样其他消费者可以继续处理。消息队列除了提供解耦功能之外，
它还能够对生产者和消费者进行独立的伸缩（scale），以及提供对错误处理的容错能力。

**发布/订阅**  
发布/订阅（pub/sub）模式中，单个消息可以被**多个订阅者并发的获取和处理**。

![发布/订阅]()

一般来说，订阅有两种类型：  
1. 临时（ephemeral）订阅，这种订阅只有在消费者启动并且运行的时候才存在。一旦消费者退出，相应的订阅以及尚未处理的消息就会丢失；
2. 持久（durable）订阅，这种订阅会一直存在，除非主动去删除。消费者退出后，消息系统会继续维护该订阅，并且后续消息可以被继续处理。

## <span id="RabbitMQ">RabbitMQ</span>
RabbitMQ 作为消息中间件的一种实现，常常被当作一种**服务总线**来使用。RabbitMQ 原生就支持上面提到的两种消息模式。
>服务总线：简单来说就是服务间数据通信的一种通道。（应该）

**队列**  
RabbitMQ 支持典型的开箱即用的消息队列。开发者可以定义一个命名队列，然后发布者可以向这个命名队列中发送消息。
最后消费者可以通过这个命名队列获取待处理的消息。

**消息交换器(Exchange)**  
RabbitMQ 使用**消息交换器**（交换机 Exchange）来实现发布/订阅模式。发布者可以把消息发布到消息交换器上而不用知道这些消息都有哪些订阅者。

每一个订阅了交换器的消费者都会创建一个队列；然后消息交换器会把生产的消息放入队列以供消费者消费。
消息交换器也可以基于各种路由规则为一些订阅者过滤消息。

![RabbitMQ消息交换器]()

RabbitMQ 支持临时和持久两种订阅类型，消费者可以调用 RabbitMQ 的 API 来选择想要的订阅类型。

根据 RabbitMQ 的架构设计，也可以创建一种混合方法——多个订阅者形成一个组，然后在组内以竞争关系作为消费者去处理某个具体队列上的消息，
这种由订阅者构成的组我们称为消费者组。按照这种方式，我们实现了发布/订阅模式，同时也能够很好的伸缩（scale-up）订阅者去处理收到的消息。

![发布/订阅与队列的联合使用]()

## <span id="Kafka">Kafka</span>
Kafka 不是消息中间件的一种实现，相反，它只是一种分布式流式系统。不同于基于队列和交换器的 RabbitMQ，
Kafka 的存储层是使用分区事务日志来实现的。

**主题(topic)**  
Kafka 没有实现队列这种东西，相应的，Kafka 按照类别存储记录集，并且把这种类别称为主题(topic)。

Kafka 为每个主题维护一个消息分区日志。每个分区都是由有序的不可变的记录序列组成，并且消息都是连续的被追加在尾部。当消息到达时，
Kafka 就会把他们追加到分区尾部。默认情况下，Kafka 使用轮询分区器（partitioner）把消息一致的分配到多个分区上。

Kafka 可以改变创建消息逻辑流的行为。  
例如，在一个多租户的应用中，我们可以根据每个消息中的租户 ID 创建消息流。确保来自相同逻辑流上的消息映射到相同分区上，
这就保证了消息能够按照顺序提供给消费者。

消费者通过维护分区的偏移（或者说索引）来顺序的读出消息，然后消费消息。

单个消费者可以消费多个不同的主题，并且消费者的数量可以伸缩到可获取的最大分区数量。所以在创建主题的时候，要考虑在创建的主题上预期的消息吞吐量。

消费同一个主题的多个消费者构成的组称为消费者组。通过 Kafka 提供的 API 可以处理同一消费者组中多个消费者之间的分区平衡以及消费者当前分区偏移的存储。

**Kafka实现的消息模式**  
Kafka 的实现很好地契合发布/订阅模式。

生产者可以向一个具体的主题发送消息，然后多个消费者组可以消费相同的消息；每一个消费者组都可以独立的伸缩去处理相应的负载。
由于消费者维护自己的分区偏移，所以他们可以选择持久订阅或者临时订阅，
持久订阅在重启之后不会丢失偏移而临时订阅在重启之后会丢失偏移并且每次重启之后都会从分区中最新的记录开始读取。

Kafka 是按照**预先配置好的时间**保留分区中的消息，而不是根据消费者是否消费了这些消息；这种保留机制可以让消费者自由的重读之前的消息。
另外，开发者也可以利用 Kafka 的存储层来实现诸如事件溯源和日志审计功能。

